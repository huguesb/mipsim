
MIPSim : a simple MIPS simulator written as a school project.

License
-------

The source code is available under BSD license. However, due to the dependency
on other libraries (most notably GNU readline), executables are licensed under
the terms of the GPL.


Build instructions
------------------

You need a C compiler to build MIPSim, preferably GCC but any C99 conformant
compiler should do.

Instead of a handwritten Makefile, a qmake project file is provided.

Building is as simple as :

$ qmake && make

Please note that GNU readline is required to build MIPSim. This library is
available by default on most *Nixes but might be more difficult to obtain
under Windows...


Usage
-----

simips [options] program

Options :
  -t addr            : specify base address of text section (for relocation)
  -d addr            : specify base address of data section (for relocation)
  -s size            : specify maximum amount of memory available to simulator
  --debug            : enable debug output
  --debug-log file   : specify file in which to redirect debug output
  --trace            : enable trace output (can be toggled on off in shell)
  --trace-log file   : specify file in which to redirect trace output
  --version          : display version and exit


Documentation
-------------

You can obtain API docs using Doxygen

$ doxygen


Shell
-----

MIPSim basic interface is a GDB-like shell supporting the command set described
below. Parameters in angle bracket are mandatory, parameters in square brackets
are optional.

MIPSim shell provides advanced command editing (with, e.g. tab completion) and
command history thanks to GNU readline library. Additionaly, most numerical
parameters can be arbitrary mathematical expression with C operators and literals
can be either register names, ELF symbols or immediates in base 8, 10 or 16.

IMPORTANT : parameter splitting is strict. If you want to use whitspaces in
mathematical expressions for readability, double-quote the parameter.


* load <filepath>
--------------------------------------------------------------------------------
 Short-hand : l
 
 Loads an ELF binary (executable or relocatable) and map it into the memory of
 the simulated  machine. PC is moved to the entry point or, if none exists, to
 the start of the .text section.
 
 Note : binaries MAY NOT contain references to external symbols.


* run [address]
--------------------------------------------------------------------------------
 Short-hand : r
 GDB equiv  : continue/jump
 
 Resume the execution of the simulated machine from the supplied address (from
 the current  value of the PC by default)
 
 
* quit
--------------------------------------------------------------------------------
 Short-hand : q
 Alias      : exit
 GDB equiv  : quit
 
 Quit MIPSim
 
 
* help [command]
--------------------------------------------------------------------------------
 Short-hand : h
 GDB equiv  : help
 
 Display a list of supported commands if no parameter passed. Display command
 specific help  when given a parameter.


* step [count]
--------------------------------------------------------------------------------
 Short-hand : s
 GDB equiv  : nexti
 
 Executes [count] instructions (default is 1). A branch and its delay slot are
 considered as a  single instruction.
 
 A procedure call and all the subsequent instructions until procedure return are
 considered as  a single instruction
 

* stepi [count]
--------------------------------------------------------------------------------
 Short-hand : si
 GDB equiv  : stepi
 
 Executes [count] instructions (default is 1). A branch and its delay slot are
 considered as a
 single instruction.
 
 
* dump
--------------------------------------------------------------------------------
 Short-hand : d
 GDB equiv  : info registers
 
 Dump informations about all processor registers.
 
 
* trace [1 | 0]
--------------------------------------------------------------------------------
 Short-hand : t
 
 Toggle trace output.
 
 
* dasm [start] [end]
--------------------------------------------------------------------------------

 Disassemble memory. Non-executable memory will be disassembled as .word
 directives.
 
 If no start parameter is provided the whole .text section will be disasembled.
 If only the start parameter is provided, end will default to start (only one
 instruction will  be shown).
 
 
* dreg [reg]
--------------------------------------------------------------------------------

 Display the content of a register. The parameter can be either a register number
 or a mnemonic, with or without a $ prefix. Using mnemonic one can also access
 the contents PC, HI, LO and coprocessor registers.

 
* sreg <reg> <value>
--------------------------------------------------------------------------------

 Set the content of a register. First parameter can be either a register number
 or a mnemonic, with or without a $ prefix. Using mnemonic one can also access
 the contents PC, HI, LO and coprocessor registers.

 
* dmem <start> [end]
--------------------------------------------------------------------------------

 Display the content of memory region delimited by start and end parameters. If
 not provided, end default to start + 3*16


* smem <address> <value> [bytecount]
--------------------------------------------------------------------------------

 Set the content of a memory cell. If value is larger than a byte, a valid
 bytecount parameter must be provided. Bytecount can be either 1, 2 or 4.

 
* addbp <start> [end] [mask] [type]
--------------------------------------------------------------------------------
 GDB equiv  : break
 
 Create a breakpoint.
 
 Breakpoint is hit when tested value V verifies :
    start <= (V & mask) <= end
    
 Value being tested depends on the breakpoint type :
 
   type |  value tested
 ----------------------
   memr | memory address passed to lb, lh, lw...
   memw | memory address passed to sb, sh, sw...
   memx | memory address of current instruciton (i.e PC)
 opcode | current instruction
 
 Defaults :
   end  = start
   mask = 0xFFFFFFFF
   type = memx
   

* rmbp [id]
--------------------------------------------------------------------------------

 Remove a breakpoint when given a parameter, all breakpoints otherwise
 
 
* dbp [id]
--------------------------------------------------------------------------------

 Display information about a breakpoint when given a parameter, about all
 breakpoints otherwise
 
 
* mmap [start] [size] [flags]
--------------------------------------------------------------------------------
 
 When invoked without parameters, display all memory mappings of the simulated
 machine, Otherwise create a new mapping.
 
 Mappings MAY NOT overlap.
 
 Default size value is the amount of memory needed to reach next page boundary.
 
 Flags is in {w, x, wx}. wx is accepted as an alias to wx but its use is
 discouraged.
 
 Default flags value is w.



Limitations
-----------

MIPSim can only run valid ELF32 binaries targeted to the MIPS I-IV architecture.
Additionally binaries must not have any reference to external symbols (i.e, no
shared libs...)

Such binaries can be obtained via a cross-compiler toolchain (e.g GCC build for
mips-elf target)

MIPSim does not emulate a MIPS pipeline and is not very accurate in terms of
instruction / memory timings : it just goes through the opcodes as fast as it
can without any effort to "harmonize" the time spent on each opcode...

MIPSim does not emulate any peripheral. Minimal I/O is supported via a few
syscalls and a hackish emulation of IDT/PMON monitors.

